#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    int    fd[2];
    // Переменная для хранения результата вызова функции fork
    int    result;
    // Переменная для хранения количества прочитанных или записанных байт
    size_t size;
    // Массив для хранения прочитанной строки
    char   byte_str[14];

    // Команда, которую мы хотим выполнить
    const char cmd[] = "/bin/ls";

    // Создаем канал
    if(pipe(fd) < 0)
    {
        // Если создание канала не удалось, выводим сообщение об ошибке и завершаем программу
        printf("Can\'t open pipe\n");
        exit(-1);
    }

    // Создаем дочерний процесс
    result = fork();

    // Если создание дочернего процесса не удалось, выводим сообщение об ошибке и завершаем программу
    if(result < 0)
    {
        printf("Can\'t fork child\n");
        exit(-1);
    }
    // Если мы находимся в родительском процессе (result > 0)
    else if (result > 0)
    {
        // Закрываем входной конец канала, так как мы не будем читать из него
        close(fd[0]);

        // Записываем команду в выходной конец канала
        size = write(fd[1], cmd, sizeof(cmd));

        // Если запись не удалась или было записано не все, выводим сообщение об ошибке и завершаем программу
        if(size != sizeof(cmd)){
            printf("Can\'t write all string to pipe\n");
            exit(-1);
        }

        // Закрываем выходной конец канала, так как мы больше не будем писать в него
        close(fd[1]);
        // Выводим сообщение о завершении родительского процесса
        printf("Parent exit\n");

    }
    // Если мы находимся в дочернем процессе (result == 0)
    else
    {
        // Закрываем выходной конец канала, так как мы не будем писать в него
        close(fd[1]);

        // Читаем команду из входного конца канала
        size = read(fd[0], byte_str, sizeof(cmd));

        // Если чтение не удалось, выводим сообщение об ошибке и завершаем программу
        if(size < 0){
            printf("Can\'t read string from pipe\n");
            exit(-1);
        }

        // Выводим прочитанную команду
        printf("%s\n", byte_str);

        if (execl(byte_str, byte_str, "-l", NULL) != 0) {
            // Если выполнение команды не удалось, выводим сообщение об ошибке и завершаем программу
            perror("Execl failed");
            exit(-1);
        }

        // Закрываем входной конец канала, так как мы больше не будем читать из него
        close(fd[0]);
    }

    return 0;
}